---
title: 动态规划系列总结
mathjax: true
comments: true
date: 2022-11-14 21:29:33
tags:
    - DP
categories:
    - algorithm
---
跟着Carl学了一波动态规划，颇有种高中刷导数压轴题的感觉，从动态规划的题型划分入手，再给出解决DP问题通用的方法论，最后`简单题用来巩固方法论，难题用来扩展思维与拔高`这一观点我十分赞同，本篇文章相比于Carl的文章，填了许多自己个人的感受和体会（其实就是好多天没写博客了想水一篇...）

<!--more-->

## 动态规划题型

> 不多说，直接上图

![DP系列](https://raw.githubusercontent.com/yzh-2002/img-hosting/main/blog/202211142150105.png)

### 解题方法论

1. 确定DP数组以及其下标的含义（最重要）
2. 确定递推公式（如果能想到DP数组的含义，那么递推公式一般都较容易推出）
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 基础题目

### 不同路径

> [题目传送门](https://leetcode.cn/problems/unique-paths/)

此题使用二维DP表还是比较好想的，但是如何把二维DP表优化为一维还是有点说法的，这种针对DP表的优化十分常见，因为DP表的内容我们不一定全部需要，我们通常在求解DP表项时只需要相邻的DP表项。

DP[i][j]:表示机器人到(i,j)的路径数，那么机器人到(i,j+1)的路径数:`dp[i][j+1] =dp[i-1][j+1]+dp[i][j]`

怎么优化为一维呢？那么首先就要理清楚转换为一维后的dp数组的含义：

dp[i]表示(j,i)的路径数，为什么不需要j呢？因为我们从0->m一行一行的求出dp的值。
```javascript
let dp =new Array(n).fill(1);
for(let j=1;j<m;j++){
    for(let i=1;i<n;i++){
        dp[i] +=dp[i-1] //dp[i] =dp[i]+dp[i-1] 此处dp[i-1]就是dp[j][i-1],dp[i]就是dp[j-1][i]
    }
}
return dp[n-1]
```

不同路径II中设置了障碍，但是不影响dp数组原本的含义，只是说有障碍的(i,j)，那么DP[i][j] =0，dp数组的递推关系不变....

### 整数拆分

> [题目传送门](https://leetcode.cn/problems/integer-break/)

这道题就比较有意思了，不同的人对dp数组含义的理解不同决定了此题的难易，我一开始就陷入了一个问题，就是整数n能拆成的正整数个数k是不确定的，那么我如何确定DP呢？（当时还在想是不是多重背包问题....）

但如果转换思路，把dp[i]看作整数i拆分的数之和的最大值（**具体怎么拆我们不再关心**），那么问题就迎刃而解

```javascript
// 初始化
let dp =[]
dp[2] =1;
for (let i=3;i<=n;i++){
   for(let j=1;j<i-1;j++){ //j<i-1是为了保证i-j>=2 第一处坑
    // dp[i] =Math.max(dp[i],dp[i-j]*j)
    dp[i] =Math.max(dp[i],Math.max((i-j)*j,dp[i-j]*j)) //题目要求k>=2，因此还需要把(i-j)*j单独拿出来比较，第二处坑
   }
}
return dp[n]
```

虽说是迎刃而解，但是实际写的时候还是有很多坑的，比如上面两处提到的....所以写算法题之前一定要多思考，思维严谨一些....

### 不同的二叉搜索树

> [题目传送门](https://leetcode.cn/problems/unique-binary-search-trees/)

此题dp数组的含义很容易想到，难就难在推导公式不容易得出。

## 背包问题

### 理论基础

> 标准的01背包的题目：有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤？

最简单的想法就是暴力枚举，每一件物品都只有两种状态，因此可以使用回溯法（回溯，贪心，暴力枚举这些关键词回头要查一查）搜索出所有的情况，此时时间复杂度为O(2^n)，指数级别，排除。

#### 二维DP数组

dp[i][j]表示从下标[0-i]的物品里面任意取，放进容量为j的背包中。（这个dp数组就感觉挺莫名其妙的，难想....）

下面来推导一下递归公式，关于dp[i][j]，有两种可能的情况：

1. 由dp[i-1][j]推出，即背包容量为j，里面不放物品i的最大值，此时dp[i][j] =dp[i-1][j]
    - 那有没有可能从dp[i-2][j]推出呢？
    - 很容易想到dp[x][j] >=dp[y][j] 当x>=y时。
    - 此种情况实则是i物品性价比极低的情况
2. 由dp[i-1][j-weight[i]]推出，此时dp[i][j] =dp[i-1][j-weight[i]]+value[i]
    - 那有没有可能从dp[i][j-weight[i]]中推出呢？
    - 由上面的推导可以得知：dp[i][j-weight[i]]>=dp[i-1][j-weight[i]]，那么为什么不使用前者而是用后者呢？
    - 
    - 此种情况实则是i物品性价比极高的情况


## TO BE CONTINUED